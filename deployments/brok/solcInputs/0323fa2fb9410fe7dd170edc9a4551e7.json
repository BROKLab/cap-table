{
  "language": "Solidity",
  "sources": {
    "contracts/capTable/CapTableQue.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.5;\n\nimport \"./Controllable.sol\";\nimport \"./CapTableRegistry.sol\";\n\ncontract CapTableQue is Controllable {\n    uint256 internal _quedCount;\n    uint256 internal _approvedCount;\n    uint256 internal _declinedCount;\n    address[] internal _capTablesQue;\n    mapping(address => uint256) internal _capTableStatus; // 0:not used 1:qued 2:approved 3:declined\n    CapTableRegistry internal _CAP_TABLE_REGISTRY;\n    mapping(address => bytes32) internal _capTableUuid;\n\n    event qued(address indexed capTable);\n    event statusUpdate(\n        address indexed capTable,\n        uint256 status,\n        bytes32 reason\n    );\n\n    constructor(address[] memory controllers)\n        Controllable(controllers)\n    {}\n\n    function setRegistry(address adr) external {\n        require(isController(msg.sender), \"msg.sender not controller\");\n        _CAP_TABLE_REGISTRY = CapTableRegistry(adr);\n    }\n\n    function getRegistry() external view returns (address capTableRegistry) {\n        return address(_CAP_TABLE_REGISTRY);\n    }\n\n    function add(address adr, bytes32 uuid) external {\n        require(adr != address(0), \"No empty address\");\n        require(\n            _capTableStatus[adr] == uint256(0),\n            \"Can only que address one-time\"\n        );\n        _capTablesQue.push(adr);\n        _quedCount++;\n        _capTableStatus[adr] = 1;\n        _capTableUuid[adr] = uuid;\n        emit qued(adr);\n    }\n\n    function process(\n        address adr,\n        bool approved,\n        bytes32 reason\n    ) external {\n        // require(adr != address(0), \"No empty address\");\n        // require(isController(msg.sender), \"msg.sender not controller\");\n        // require(_capTableStatus[adr] == 1, \"Must be in que to process\");\n        _quedCount--;\n\n        if (approved) {\n            _CAP_TABLE_REGISTRY.add(adr, _capTableUuid[adr]);\n            _approvedCount++;\n            _capTableStatus[adr] = 2;\n        } else {\n            _declinedCount++;\n            _capTableStatus[adr] = 3;\n        }\n        uint256 status = approved ? 2 : 3;\n        emit statusUpdate(adr, status, reason);\n    }\n\n    function getStatus(address adr) external view returns (uint256) {\n        return _capTableStatus[adr];\n    }\n\n    function info(address adr) external view returns (uint256 status, bytes32 uuid) {\n        return (_capTableStatus[adr],_capTableUuid[adr] );\n    }\n\n    function list() external view returns (address[] memory capTableList) {\n        return _capTablesQue;\n    }\n\n    function listQued() external view returns (address[] memory capTableList) {\n        address[] memory capTableAddressArray = new address[](_quedCount);\n        uint256 indexForCapTableAddressArray;\n        for (uint256 i = 0; i < _capTablesQue.length; i++) {\n            if (_capTableStatus[_capTablesQue[i]] == 1) {\n                capTableAddressArray[indexForCapTableAddressArray] = _capTablesQue[i];\n                indexForCapTableAddressArray++;\n            }\n        }\n        return capTableAddressArray;\n    }\n\n    function listApproved()\n        external\n        view\n        returns (address[] memory capTableList)\n    {\n        address[] memory capTableAddressArray = new address[](_approvedCount);\n        uint256 indexForCapTableAddressArray;\n        for (uint256 i = 0; i < _capTablesQue.length; i++) {\n            if (_capTableStatus[_capTablesQue[i]] == 2) {\n                capTableAddressArray[indexForCapTableAddressArray] = _capTablesQue[i];\n                indexForCapTableAddressArray++;\n            }\n        }\n        return capTableAddressArray;\n    }\n\n    function listDeclined()\n        external\n        view\n        returns (address[] memory capTableList)\n    {\n        address[] memory capTableAddressArray = new address[](_declinedCount);\n        uint256 indexForCapTableAddressArray;\n        for (uint256 i = 0; i < _capTablesQue.length; i++) {\n            if (_capTableStatus[_capTablesQue[i]] == 3) {\n                capTableAddressArray[indexForCapTableAddressArray] = _capTablesQue[i];\n                indexForCapTableAddressArray++;\n            }\n        }\n        return capTableAddressArray;\n    }\n}\n"
    },
    "contracts/capTable/Controllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.5;\n\n\ncontract Controllable {\n    address[] internal _controllers;\n    mapping(address => bool) internal _isController;\n\n    constructor(address[] memory controllers) {\n        _setControllers(controllers);\n    }\n\n    function controllers() external view returns (address[] memory) {\n        return _controllers;\n    }\n\n    function setControllers(address[] calldata operators) external {\n        require(isController(msg.sender), \"msg.sender not controller\");\n        _setControllers(operators);\n    }\n\n    function isController(address adr) public view returns (bool) {\n        return _isController[adr];\n    }\n\n    function _setControllers(address[] memory adresses) internal {\n        for (uint256 i = 0; i < _controllers.length; i++) {\n            _isController[_controllers[i]] = false;\n        }\n        for (uint256 j = 0; j < adresses.length; j++) {\n            _isController[adresses[j]] = true;\n        }\n        _controllers = adresses;\n    }\n}\n"
    },
    "contracts/capTable/CapTableRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.5;\n\nimport \"./Controllable.sol\";\n\ncontract CapTableRegistry is Controllable {\n    address[] internal _capTables;\n    mapping(address => bool) internal _active;\n    mapping(address => bytes32) internal _addressToUuid;\n    mapping(bytes32 => address) internal _uuidToAddress;\n    uint256 internal _activeCapTables;\n\n    event capTableAdded(address indexed capTableAddress);\n    event capTableRemoved(address indexed capTableRemoved);\n\n    constructor(address[] memory controllers)\n        Controllable(controllers)\n    {}\n\n    function add(address adr, bytes32 uuid) external {\n        _addCapTable(adr, uuid);\n    }\n\n    function remove(address adr) external {\n        _removeCapTable(adr);\n    }\n\n    function list() external view returns (address[] memory capTableList) {\n        return _capTables;\n    }\n\n    function info(address adr) external view returns (bytes32 uuid, bool active){\n        return (_addressToUuid[adr],_active[adr]);\n    }\n    function listActive()\n        external\n        view\n        returns (address[] memory capTableList)\n    {\n        require(_activeCapTables > 0, \"CapTable list is empty\");\n        address[] memory capTableAddressArray = new address[](_activeCapTables);\n        uint256 indexForCapTableAddressArray;\n        for (uint256 i = 0; i < _capTables.length; i++) {\n            if (_active[_capTables[i]]) {\n                capTableAddressArray[indexForCapTableAddressArray] = _capTables[i];\n                indexForCapTableAddressArray++;\n            }\n        }\n        return capTableAddressArray;\n    }\n\n    function _addCapTable(address adr, bytes32 uuid) internal {\n        require(isController(msg.sender), \"msg.sender not controller\");\n        _capTables.push(adr);\n        _active[adr] = true;\n        _addressToUuid[adr] = uuid;\n        _uuidToAddress[uuid] = adr;\n        _activeCapTables++;\n        emit capTableAdded(adr);\n    }\n\n    function _removeCapTable(address adr) internal {\n        require(isController(msg.sender), \"msg.sender not controller\");\n        bytes32 uuid = _addressToUuid[adr];\n        _active[adr] = false;\n        _addressToUuid[adr] = bytes32(0);\n        _uuidToAddress[uuid] = address(0);\n        _activeCapTables--;\n        emit capTableRemoved(adr);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 50
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}