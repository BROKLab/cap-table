/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface ERC1400TokensValidatorMockInterface extends ethers.utils.Interface {
  functions: {
    "renounceAllowlistAdmin(address)": FunctionFragment;
    "registerTokenSetup(address,uint8,bool,bool,bool,bool,address[])": FunctionFragment;
    "retrieveHoldData(address,bytes32)": FunctionFragment;
    "totalSupplyOnHold(address)": FunctionFragment;
    "balanceOnHold(address,address)": FunctionFragment;
    "holdFrom(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "canImplementInterfaceForAddress(bytes32,address)": FunctionFragment;
    "usedCertificateNonce(address,address)": FunctionFragment;
    "preHoldFor(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "addBlocklisted(address,address)": FunctionFragment;
    "paused(address)": FunctionFragment;
    "isPauser(address,address)": FunctionFragment;
    "renounceCertificateSigner(address)": FunctionFragment;
    "renouncePauser(address)": FunctionFragment;
    "addAllowlisted(address,address)": FunctionFragment;
    "isAllowlistAdmin(address,address)": FunctionFragment;
    "totalSupplyOnHoldByPartition(address,bytes32)": FunctionFragment;
    "tokensToValidate(bytes,bytes32,address,address,address,uint256,bytes,bytes)": FunctionFragment;
    "preHoldForWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "executeHold(address,bytes32,uint256,bytes32)": FunctionFragment;
    "unpause(address)": FunctionFragment;
    "spendableBalanceOf(address,address)": FunctionFragment;
    "renounceMinter(address)": FunctionFragment;
    "usedCertificateSalt(address,bytes32)": FunctionFragment;
    "isAllowlisted(address,address)": FunctionFragment;
    "setGranularityByPartition(address,bytes32,uint256)": FunctionFragment;
    "removeAllowlisted(address,address)": FunctionFragment;
    "executeHoldAndKeepOpen(address,bytes32,uint256,bytes32)": FunctionFragment;
    "spendableBalanceOfByPartition(address,bytes32,address)": FunctionFragment;
    "hold(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "pause(address)": FunctionFragment;
    "holdWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "canValidate(address,bytes,bytes32,address,address,address,uint256,bytes,bytes)": FunctionFragment;
    "holdFromWithExpirationDate(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)": FunctionFragment;
    "removeBlocklisted(address,address)": FunctionFragment;
    "isCertificateSigner(address,address)": FunctionFragment;
    "isBlocklistAdmin(address,address)": FunctionFragment;
    "isBlocklisted(address,address)": FunctionFragment;
    "granularityByPartition(address,bytes32)": FunctionFragment;
    "retrieveTokenSetup(address)": FunctionFragment;
    "renewHoldWithExpirationDate(address,bytes32,uint256,bytes)": FunctionFragment;
    "releaseHold(address,bytes32)": FunctionFragment;
    "addBlocklistAdmin(address,address)": FunctionFragment;
    "addCertificateSigner(address,address)": FunctionFragment;
    "renewHold(address,bytes32,uint256,bytes)": FunctionFragment;
    "removeAllowlistAdmin(address,address)": FunctionFragment;
    "renounceBlocklistAdmin(address)": FunctionFragment;
    "balanceOnHoldByPartition(address,bytes32,address)": FunctionFragment;
    "removeCertificateSigner(address,address)": FunctionFragment;
    "addPauser(address,address)": FunctionFragment;
    "removeBlocklistAdmin(address,address)": FunctionFragment;
    "removePauser(address,address)": FunctionFragment;
    "addAllowlistAdmin(address,address)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "renounceAllowlistAdmin",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "registerTokenSetup",
    values: [string, BigNumberish, boolean, boolean, boolean, boolean, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "retrieveHoldData",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupplyOnHold",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOnHold",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "holdFrom",
    values: [
      string,
      BytesLike,
      string,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "canImplementInterfaceForAddress",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "usedCertificateNonce",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "preHoldFor",
    values: [
      string,
      BytesLike,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addBlocklisted",
    values: [string, string]
  ): string;
  encodeFunctionData(functionFragment: "paused", values: [string]): string;
  encodeFunctionData(
    functionFragment: "isPauser",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceCertificateSigner",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "renouncePauser",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "addAllowlisted",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isAllowlistAdmin",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "totalSupplyOnHoldByPartition",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "tokensToValidate",
    values: [
      BytesLike,
      BytesLike,
      string,
      string,
      string,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "preHoldForWithExpirationDate",
    values: [
      string,
      BytesLike,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "executeHold",
    values: [string, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values: [string]): string;
  encodeFunctionData(
    functionFragment: "spendableBalanceOf",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceMinter",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "usedCertificateSalt",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isAllowlisted",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setGranularityByPartition",
    values: [string, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeAllowlisted",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "executeHoldAndKeepOpen",
    values: [string, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "spendableBalanceOfByPartition",
    values: [string, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "hold",
    values: [
      string,
      BytesLike,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(functionFragment: "pause", values: [string]): string;
  encodeFunctionData(
    functionFragment: "holdWithExpirationDate",
    values: [
      string,
      BytesLike,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "canValidate",
    values: [
      string,
      BytesLike,
      BytesLike,
      string,
      string,
      string,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "holdFromWithExpirationDate",
    values: [
      string,
      BytesLike,
      string,
      string,
      string,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "removeBlocklisted",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isCertificateSigner",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isBlocklistAdmin",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isBlocklisted",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "granularityByPartition",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "retrieveTokenSetup",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "renewHoldWithExpirationDate",
    values: [string, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "releaseHold",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "addBlocklistAdmin",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "addCertificateSigner",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "renewHold",
    values: [string, BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "removeAllowlistAdmin",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceBlocklistAdmin",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "balanceOnHoldByPartition",
    values: [string, BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeCertificateSigner",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "addPauser",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeBlocklistAdmin",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removePauser",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "addAllowlistAdmin",
    values: [string, string]
  ): string;

  decodeFunctionResult(
    functionFragment: "renounceAllowlistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerTokenSetup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "retrieveHoldData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSupplyOnHold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceOnHold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "holdFrom", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "canImplementInterfaceForAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "usedCertificateNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "preHoldFor", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "addBlocklisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isPauser", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceCertificateSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renouncePauser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addAllowlisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAllowlistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalSupplyOnHoldByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokensToValidate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "preHoldForWithExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeHold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "spendableBalanceOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceMinter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "usedCertificateSalt",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAllowlisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setGranularityByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeAllowlisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeHoldAndKeepOpen",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "spendableBalanceOfByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hold", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "holdWithExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canValidate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "holdFromWithExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeBlocklisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isCertificateSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isBlocklistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isBlocklisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "granularityByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "retrieveTokenSetup",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renewHoldWithExpirationDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "releaseHold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addBlocklistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addCertificateSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "renewHold", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "removeAllowlistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceBlocklistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "balanceOnHoldByPartition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeCertificateSigner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addPauser", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "removeBlocklistAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removePauser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addAllowlistAdmin",
    data: BytesLike
  ): Result;

  events: {
    "HoldCreated(address,bytes32,bytes32,address,address,address,uint256,uint256,bytes32)": EventFragment;
    "HoldReleased(address,bytes32,address,uint8)": EventFragment;
    "HoldRenewed(address,bytes32,address,uint256,uint256)": EventFragment;
    "HoldExecuted(address,bytes32,address,uint256,uint256,bytes32)": EventFragment;
    "HoldExecutedAndKeptOpen(address,bytes32,address,uint256,uint256,bytes32)": EventFragment;
    "BlocklistedAdded(address,address)": EventFragment;
    "BlocklistedRemoved(address,address)": EventFragment;
    "BlocklistAdminAdded(address,address)": EventFragment;
    "BlocklistAdminRemoved(address,address)": EventFragment;
    "AllowlistedAdded(address,address)": EventFragment;
    "AllowlistedRemoved(address,address)": EventFragment;
    "AllowlistAdminAdded(address,address)": EventFragment;
    "AllowlistAdminRemoved(address,address)": EventFragment;
    "CertificateSignerAdded(address,address)": EventFragment;
    "CertificateSignerRemoved(address,address)": EventFragment;
    "Paused(address,address)": EventFragment;
    "Unpaused(address,address)": EventFragment;
    "PauserAdded(address,address)": EventFragment;
    "PauserRemoved(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "HoldCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldReleased"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldRenewed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "HoldExecutedAndKeptOpen"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BlocklistedAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BlocklistedRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BlocklistAdminAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BlocklistAdminRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowlistedAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowlistedRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowlistAdminAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AllowlistAdminRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CertificateSignerAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "CertificateSignerRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PauserAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PauserRemoved"): EventFragment;
}

export class ERC1400TokensValidatorMock extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: ERC1400TokensValidatorMockInterface;

  functions: {
    renounceAllowlistAdmin(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "renounceAllowlistAdmin(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    registerTokenSetup(
      token: string,
      certificateActivated: BigNumberish,
      allowlistActivated: boolean,
      blocklistActivated: boolean,
      granularityByPartitionActivated: boolean,
      holdsActivated: boolean,
      operators: string[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "registerTokenSetup(address,uint8,bool,bool,bool,bool,address[])"(
      token: string,
      certificateActivated: BigNumberish,
      allowlistActivated: boolean,
      blocklistActivated: boolean,
      granularityByPartitionActivated: boolean,
      holdsActivated: boolean,
      operators: string[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    retrieveHoldData(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      partition: string;
      sender: string;
      recipient: string;
      notary: string;
      value: BigNumber;
      expiration: BigNumber;
      secretHash: string;
      secret: string;
      status: number;
      0: string;
      1: string;
      2: string;
      3: string;
      4: BigNumber;
      5: BigNumber;
      6: string;
      7: string;
      8: number;
    }>;

    "retrieveHoldData(address,bytes32)"(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      partition: string;
      sender: string;
      recipient: string;
      notary: string;
      value: BigNumber;
      expiration: BigNumber;
      secretHash: string;
      secret: string;
      status: number;
      0: string;
      1: string;
      2: string;
      3: string;
      4: BigNumber;
      5: BigNumber;
      6: string;
      7: string;
      8: number;
    }>;

    totalSupplyOnHold(
      token: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "totalSupplyOnHold(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    balanceOnHold(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "balanceOnHold(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    holdFrom(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "holdFrom(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "canImplementInterfaceForAddress(bytes32,address)"(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    usedCertificateNonce(
      token: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "usedCertificateNonce(address,address)"(
      token: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    preHoldFor(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "preHoldFor(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    addBlocklisted(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addBlocklisted(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    paused(
      token: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "paused(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    isPauser(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "isPauser(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    renounceCertificateSigner(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "renounceCertificateSigner(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    renouncePauser(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "renouncePauser(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    addAllowlisted(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addAllowlisted(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    isAllowlistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "isAllowlistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    totalSupplyOnHoldByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "totalSupplyOnHoldByPartition(address,bytes32)"(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    tokensToValidate(
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "tokensToValidate(bytes,bytes32,address,address,address,uint256,bytes,bytes)"(
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    preHoldForWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "preHoldForWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    executeHold(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "executeHold(address,bytes32,uint256,bytes32)"(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    unpause(token: string, overrides?: Overrides): Promise<ContractTransaction>;

    "unpause(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    spendableBalanceOf(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "spendableBalanceOf(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    renounceMinter(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "renounceMinter(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    usedCertificateSalt(
      token: string,
      salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "usedCertificateSalt(address,bytes32)"(
      token: string,
      salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    isAllowlisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "isAllowlisted(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    setGranularityByPartition(
      token: string,
      partition: BytesLike,
      granularity: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "setGranularityByPartition(address,bytes32,uint256)"(
      token: string,
      partition: BytesLike,
      granularity: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    removeAllowlisted(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "removeAllowlisted(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    executeHoldAndKeepOpen(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "executeHoldAndKeepOpen(address,bytes32,uint256,bytes32)"(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    spendableBalanceOfByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "spendableBalanceOfByPartition(address,bytes32,address)"(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    hold(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "hold(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    pause(token: string, overrides?: Overrides): Promise<ContractTransaction>;

    "pause(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    holdWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "holdWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    canValidate(
      token: string,
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "canValidate(address,bytes,bytes32,address,address,address,uint256,bytes,bytes)"(
      token: string,
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    holdFromWithExpirationDate(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "holdFromWithExpirationDate(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    removeBlocklisted(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "removeBlocklisted(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    isCertificateSigner(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "isCertificateSigner(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    isBlocklistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "isBlocklistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    isBlocklisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "isBlocklisted(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    granularityByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "granularityByPartition(address,bytes32)"(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    retrieveTokenSetup(
      token: string,
      overrides?: CallOverrides
    ): Promise<{
      0: number;
      1: boolean;
      2: boolean;
      3: boolean;
      4: boolean;
      5: string[];
    }>;

    "retrieveTokenSetup(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<{
      0: number;
      1: boolean;
      2: boolean;
      3: boolean;
      4: boolean;
      5: string[];
    }>;

    renewHoldWithExpirationDate(
      token: string,
      holdId: BytesLike,
      expiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "renewHoldWithExpirationDate(address,bytes32,uint256,bytes)"(
      token: string,
      holdId: BytesLike,
      expiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    releaseHold(
      token: string,
      holdId: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "releaseHold(address,bytes32)"(
      token: string,
      holdId: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    addBlocklistAdmin(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addBlocklistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    addCertificateSigner(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addCertificateSigner(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    renewHold(
      token: string,
      holdId: BytesLike,
      timeToExpiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "renewHold(address,bytes32,uint256,bytes)"(
      token: string,
      holdId: BytesLike,
      timeToExpiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    removeAllowlistAdmin(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "removeAllowlistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    renounceBlocklistAdmin(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "renounceBlocklistAdmin(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    balanceOnHoldByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "balanceOnHoldByPartition(address,bytes32,address)"(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    removeCertificateSigner(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "removeCertificateSigner(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    addPauser(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addPauser(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    removeBlocklistAdmin(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "removeBlocklistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    removePauser(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "removePauser(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    addAllowlistAdmin(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "addAllowlistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;
  };

  renounceAllowlistAdmin(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "renounceAllowlistAdmin(address)"(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  registerTokenSetup(
    token: string,
    certificateActivated: BigNumberish,
    allowlistActivated: boolean,
    blocklistActivated: boolean,
    granularityByPartitionActivated: boolean,
    holdsActivated: boolean,
    operators: string[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "registerTokenSetup(address,uint8,bool,bool,bool,bool,address[])"(
    token: string,
    certificateActivated: BigNumberish,
    allowlistActivated: boolean,
    blocklistActivated: boolean,
    granularityByPartitionActivated: boolean,
    holdsActivated: boolean,
    operators: string[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  retrieveHoldData(
    token: string,
    holdId: BytesLike,
    overrides?: CallOverrides
  ): Promise<{
    partition: string;
    sender: string;
    recipient: string;
    notary: string;
    value: BigNumber;
    expiration: BigNumber;
    secretHash: string;
    secret: string;
    status: number;
    0: string;
    1: string;
    2: string;
    3: string;
    4: BigNumber;
    5: BigNumber;
    6: string;
    7: string;
    8: number;
  }>;

  "retrieveHoldData(address,bytes32)"(
    token: string,
    holdId: BytesLike,
    overrides?: CallOverrides
  ): Promise<{
    partition: string;
    sender: string;
    recipient: string;
    notary: string;
    value: BigNumber;
    expiration: BigNumber;
    secretHash: string;
    secret: string;
    status: number;
    0: string;
    1: string;
    2: string;
    3: string;
    4: BigNumber;
    5: BigNumber;
    6: string;
    7: string;
    8: number;
  }>;

  totalSupplyOnHold(
    token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "totalSupplyOnHold(address)"(
    token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  balanceOnHold(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "balanceOnHold(address,address)"(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  holdFrom(
    token: string,
    holdId: BytesLike,
    sender: string,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    timeToExpiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "holdFrom(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
    token: string,
    holdId: BytesLike,
    sender: string,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    timeToExpiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  canImplementInterfaceForAddress(
    interfaceHash: BytesLike,
    arg1: string,
    overrides?: CallOverrides
  ): Promise<string>;

  "canImplementInterfaceForAddress(bytes32,address)"(
    interfaceHash: BytesLike,
    arg1: string,
    overrides?: CallOverrides
  ): Promise<string>;

  usedCertificateNonce(
    token: string,
    sender: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "usedCertificateNonce(address,address)"(
    token: string,
    sender: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  preHoldFor(
    token: string,
    holdId: BytesLike,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    timeToExpiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "preHoldFor(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
    token: string,
    holdId: BytesLike,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    timeToExpiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  addBlocklisted(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addBlocklisted(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  paused(token: string, overrides?: CallOverrides): Promise<boolean>;

  "paused(address)"(token: string, overrides?: CallOverrides): Promise<boolean>;

  isPauser(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "isPauser(address,address)"(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  renounceCertificateSigner(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "renounceCertificateSigner(address)"(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  renouncePauser(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "renouncePauser(address)"(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  addAllowlisted(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addAllowlisted(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  isAllowlistAdmin(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "isAllowlistAdmin(address,address)"(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  totalSupplyOnHoldByPartition(
    token: string,
    partition: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "totalSupplyOnHoldByPartition(address,bytes32)"(
    token: string,
    partition: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  tokensToValidate(
    payload: BytesLike,
    partition: BytesLike,
    operator: string,
    from: string,
    to: string,
    value: BigNumberish,
    data: BytesLike,
    operatorData: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "tokensToValidate(bytes,bytes32,address,address,address,uint256,bytes,bytes)"(
    payload: BytesLike,
    partition: BytesLike,
    operator: string,
    from: string,
    to: string,
    value: BigNumberish,
    data: BytesLike,
    operatorData: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  preHoldForWithExpirationDate(
    token: string,
    holdId: BytesLike,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    expiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "preHoldForWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
    token: string,
    holdId: BytesLike,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    expiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  executeHold(
    token: string,
    holdId: BytesLike,
    value: BigNumberish,
    secret: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "executeHold(address,bytes32,uint256,bytes32)"(
    token: string,
    holdId: BytesLike,
    value: BigNumberish,
    secret: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  unpause(token: string, overrides?: Overrides): Promise<ContractTransaction>;

  "unpause(address)"(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  spendableBalanceOf(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "spendableBalanceOf(address,address)"(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  renounceMinter(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "renounceMinter(address)"(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  usedCertificateSalt(
    token: string,
    salt: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "usedCertificateSalt(address,bytes32)"(
    token: string,
    salt: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isAllowlisted(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "isAllowlisted(address,address)"(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  setGranularityByPartition(
    token: string,
    partition: BytesLike,
    granularity: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "setGranularityByPartition(address,bytes32,uint256)"(
    token: string,
    partition: BytesLike,
    granularity: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  removeAllowlisted(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "removeAllowlisted(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  executeHoldAndKeepOpen(
    token: string,
    holdId: BytesLike,
    value: BigNumberish,
    secret: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "executeHoldAndKeepOpen(address,bytes32,uint256,bytes32)"(
    token: string,
    holdId: BytesLike,
    value: BigNumberish,
    secret: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  spendableBalanceOfByPartition(
    token: string,
    partition: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "spendableBalanceOfByPartition(address,bytes32,address)"(
    token: string,
    partition: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  hold(
    token: string,
    holdId: BytesLike,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    timeToExpiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "hold(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
    token: string,
    holdId: BytesLike,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    timeToExpiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  pause(token: string, overrides?: Overrides): Promise<ContractTransaction>;

  "pause(address)"(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  holdWithExpirationDate(
    token: string,
    holdId: BytesLike,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    expiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "holdWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
    token: string,
    holdId: BytesLike,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    expiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  canValidate(
    token: string,
    payload: BytesLike,
    partition: BytesLike,
    operator: string,
    from: string,
    to: string,
    value: BigNumberish,
    data: BytesLike,
    operatorData: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "canValidate(address,bytes,bytes32,address,address,address,uint256,bytes,bytes)"(
    token: string,
    payload: BytesLike,
    partition: BytesLike,
    operator: string,
    from: string,
    to: string,
    value: BigNumberish,
    data: BytesLike,
    operatorData: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  holdFromWithExpirationDate(
    token: string,
    holdId: BytesLike,
    sender: string,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    expiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "holdFromWithExpirationDate(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
    token: string,
    holdId: BytesLike,
    sender: string,
    recipient: string,
    notary: string,
    partition: BytesLike,
    value: BigNumberish,
    expiration: BigNumberish,
    secretHash: BytesLike,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  removeBlocklisted(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "removeBlocklisted(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  isCertificateSigner(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "isCertificateSigner(address,address)"(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isBlocklistAdmin(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "isBlocklistAdmin(address,address)"(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isBlocklisted(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  "isBlocklisted(address,address)"(
    token: string,
    account: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  granularityByPartition(
    token: string,
    partition: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "granularityByPartition(address,bytes32)"(
    token: string,
    partition: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  retrieveTokenSetup(
    token: string,
    overrides?: CallOverrides
  ): Promise<{
    0: number;
    1: boolean;
    2: boolean;
    3: boolean;
    4: boolean;
    5: string[];
  }>;

  "retrieveTokenSetup(address)"(
    token: string,
    overrides?: CallOverrides
  ): Promise<{
    0: number;
    1: boolean;
    2: boolean;
    3: boolean;
    4: boolean;
    5: string[];
  }>;

  renewHoldWithExpirationDate(
    token: string,
    holdId: BytesLike,
    expiration: BigNumberish,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "renewHoldWithExpirationDate(address,bytes32,uint256,bytes)"(
    token: string,
    holdId: BytesLike,
    expiration: BigNumberish,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  releaseHold(
    token: string,
    holdId: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "releaseHold(address,bytes32)"(
    token: string,
    holdId: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  addBlocklistAdmin(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addBlocklistAdmin(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  addCertificateSigner(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addCertificateSigner(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  renewHold(
    token: string,
    holdId: BytesLike,
    timeToExpiration: BigNumberish,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "renewHold(address,bytes32,uint256,bytes)"(
    token: string,
    holdId: BytesLike,
    timeToExpiration: BigNumberish,
    certificate: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  removeAllowlistAdmin(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "removeAllowlistAdmin(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  renounceBlocklistAdmin(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "renounceBlocklistAdmin(address)"(
    token: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  balanceOnHoldByPartition(
    token: string,
    partition: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "balanceOnHoldByPartition(address,bytes32,address)"(
    token: string,
    partition: BytesLike,
    account: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  removeCertificateSigner(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "removeCertificateSigner(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  addPauser(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addPauser(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  removeBlocklistAdmin(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "removeBlocklistAdmin(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  removePauser(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "removePauser(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  addAllowlistAdmin(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "addAllowlistAdmin(address,address)"(
    token: string,
    account: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  callStatic: {
    renounceAllowlistAdmin(
      token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "renounceAllowlistAdmin(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    registerTokenSetup(
      token: string,
      certificateActivated: BigNumberish,
      allowlistActivated: boolean,
      blocklistActivated: boolean,
      granularityByPartitionActivated: boolean,
      holdsActivated: boolean,
      operators: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    "registerTokenSetup(address,uint8,bool,bool,bool,bool,address[])"(
      token: string,
      certificateActivated: BigNumberish,
      allowlistActivated: boolean,
      blocklistActivated: boolean,
      granularityByPartitionActivated: boolean,
      holdsActivated: boolean,
      operators: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    retrieveHoldData(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      partition: string;
      sender: string;
      recipient: string;
      notary: string;
      value: BigNumber;
      expiration: BigNumber;
      secretHash: string;
      secret: string;
      status: number;
      0: string;
      1: string;
      2: string;
      3: string;
      4: BigNumber;
      5: BigNumber;
      6: string;
      7: string;
      8: number;
    }>;

    "retrieveHoldData(address,bytes32)"(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      partition: string;
      sender: string;
      recipient: string;
      notary: string;
      value: BigNumber;
      expiration: BigNumber;
      secretHash: string;
      secret: string;
      status: number;
      0: string;
      1: string;
      2: string;
      3: string;
      4: BigNumber;
      5: BigNumber;
      6: string;
      7: string;
      8: number;
    }>;

    totalSupplyOnHold(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "totalSupplyOnHold(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceOnHold(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "balanceOnHold(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    holdFrom(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "holdFrom(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<string>;

    "canImplementInterfaceForAddress(bytes32,address)"(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<string>;

    usedCertificateNonce(
      token: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "usedCertificateNonce(address,address)"(
      token: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    preHoldFor(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "preHoldFor(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    addBlocklisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "addBlocklisted(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    paused(token: string, overrides?: CallOverrides): Promise<boolean>;

    "paused(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isPauser(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "isPauser(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    renounceCertificateSigner(
      token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "renounceCertificateSigner(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    renouncePauser(token: string, overrides?: CallOverrides): Promise<void>;

    "renouncePauser(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addAllowlisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "addAllowlisted(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    isAllowlistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "isAllowlistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    totalSupplyOnHoldByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "totalSupplyOnHoldByPartition(address,bytes32)"(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokensToValidate(
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "tokensToValidate(bytes,bytes32,address,address,address,uint256,bytes,bytes)"(
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    preHoldForWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "preHoldForWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    executeHold(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "executeHold(address,bytes32,uint256,bytes32)"(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    unpause(token: string, overrides?: CallOverrides): Promise<void>;

    "unpause(address)"(token: string, overrides?: CallOverrides): Promise<void>;

    spendableBalanceOf(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "spendableBalanceOf(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    renounceMinter(token: string, overrides?: CallOverrides): Promise<void>;

    "renounceMinter(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    usedCertificateSalt(
      token: string,
      salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "usedCertificateSalt(address,bytes32)"(
      token: string,
      salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isAllowlisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "isAllowlisted(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    setGranularityByPartition(
      token: string,
      partition: BytesLike,
      granularity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "setGranularityByPartition(address,bytes32,uint256)"(
      token: string,
      partition: BytesLike,
      granularity: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    removeAllowlisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "removeAllowlisted(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    executeHoldAndKeepOpen(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "executeHoldAndKeepOpen(address,bytes32,uint256,bytes32)"(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    spendableBalanceOfByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "spendableBalanceOfByPartition(address,bytes32,address)"(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hold(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "hold(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    pause(token: string, overrides?: CallOverrides): Promise<void>;

    "pause(address)"(token: string, overrides?: CallOverrides): Promise<void>;

    holdWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "holdWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    canValidate(
      token: string,
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "canValidate(address,bytes,bytes32,address,address,address,uint256,bytes,bytes)"(
      token: string,
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    holdFromWithExpirationDate(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "holdFromWithExpirationDate(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    removeBlocklisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "removeBlocklisted(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    isCertificateSigner(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "isCertificateSigner(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isBlocklistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "isBlocklistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isBlocklisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "isBlocklisted(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    granularityByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "granularityByPartition(address,bytes32)"(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    retrieveTokenSetup(
      token: string,
      overrides?: CallOverrides
    ): Promise<{
      0: number;
      1: boolean;
      2: boolean;
      3: boolean;
      4: boolean;
      5: string[];
    }>;

    "retrieveTokenSetup(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<{
      0: number;
      1: boolean;
      2: boolean;
      3: boolean;
      4: boolean;
      5: string[];
    }>;

    renewHoldWithExpirationDate(
      token: string,
      holdId: BytesLike,
      expiration: BigNumberish,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "renewHoldWithExpirationDate(address,bytes32,uint256,bytes)"(
      token: string,
      holdId: BytesLike,
      expiration: BigNumberish,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    releaseHold(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "releaseHold(address,bytes32)"(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    addBlocklistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "addBlocklistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addCertificateSigner(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "addCertificateSigner(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    renewHold(
      token: string,
      holdId: BytesLike,
      timeToExpiration: BigNumberish,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    "renewHold(address,bytes32,uint256,bytes)"(
      token: string,
      holdId: BytesLike,
      timeToExpiration: BigNumberish,
      certificate: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    removeAllowlistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "removeAllowlistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceBlocklistAdmin(
      token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "renounceBlocklistAdmin(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    balanceOnHoldByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "balanceOnHoldByPartition(address,bytes32,address)"(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeCertificateSigner(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "removeCertificateSigner(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addPauser(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "addPauser(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removeBlocklistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "removeBlocklistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    removePauser(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "removePauser(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    addAllowlistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "addAllowlistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    HoldCreated(
      token: string | null,
      holdId: BytesLike | null,
      partition: null,
      sender: null,
      recipient: null,
      notary: string | null,
      value: null,
      expiration: null,
      secretHash: null
    ): EventFilter;

    HoldReleased(
      token: string | null,
      holdId: null,
      notary: string | null,
      status: null
    ): EventFilter;

    HoldRenewed(
      token: string | null,
      holdId: null,
      notary: string | null,
      oldExpiration: null,
      newExpiration: null
    ): EventFilter;

    HoldExecuted(
      token: string | null,
      holdId: null,
      notary: string | null,
      heldValue: null,
      transferredValue: null,
      secret: null
    ): EventFilter;

    HoldExecutedAndKeptOpen(
      token: string | null,
      holdId: null,
      notary: string | null,
      heldValue: null,
      transferredValue: null,
      secret: null
    ): EventFilter;

    BlocklistedAdded(token: string | null, account: string | null): EventFilter;

    BlocklistedRemoved(
      token: string | null,
      account: string | null
    ): EventFilter;

    BlocklistAdminAdded(
      token: string | null,
      account: string | null
    ): EventFilter;

    BlocklistAdminRemoved(
      token: string | null,
      account: string | null
    ): EventFilter;

    AllowlistedAdded(token: string | null, account: string | null): EventFilter;

    AllowlistedRemoved(
      token: string | null,
      account: string | null
    ): EventFilter;

    AllowlistAdminAdded(
      token: string | null,
      account: string | null
    ): EventFilter;

    AllowlistAdminRemoved(
      token: string | null,
      account: string | null
    ): EventFilter;

    CertificateSignerAdded(
      token: string | null,
      account: string | null
    ): EventFilter;

    CertificateSignerRemoved(
      token: string | null,
      account: string | null
    ): EventFilter;

    Paused(token: string | null, account: null): EventFilter;

    Unpaused(token: string | null, account: null): EventFilter;

    PauserAdded(token: string | null, account: string | null): EventFilter;

    PauserRemoved(token: string | null, account: string | null): EventFilter;
  };

  estimateGas: {
    renounceAllowlistAdmin(
      token: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "renounceAllowlistAdmin(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    registerTokenSetup(
      token: string,
      certificateActivated: BigNumberish,
      allowlistActivated: boolean,
      blocklistActivated: boolean,
      granularityByPartitionActivated: boolean,
      holdsActivated: boolean,
      operators: string[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    "registerTokenSetup(address,uint8,bool,bool,bool,bool,address[])"(
      token: string,
      certificateActivated: BigNumberish,
      allowlistActivated: boolean,
      blocklistActivated: boolean,
      granularityByPartitionActivated: boolean,
      holdsActivated: boolean,
      operators: string[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    retrieveHoldData(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "retrieveHoldData(address,bytes32)"(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalSupplyOnHold(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "totalSupplyOnHold(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    balanceOnHold(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "balanceOnHold(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    holdFrom(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "holdFrom(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "canImplementInterfaceForAddress(bytes32,address)"(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    usedCertificateNonce(
      token: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "usedCertificateNonce(address,address)"(
      token: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    preHoldFor(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "preHoldFor(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    addBlocklisted(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "addBlocklisted(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    paused(token: string, overrides?: CallOverrides): Promise<BigNumber>;

    "paused(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isPauser(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isPauser(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    renounceCertificateSigner(
      token: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "renounceCertificateSigner(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    renouncePauser(token: string, overrides?: Overrides): Promise<BigNumber>;

    "renouncePauser(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    addAllowlisted(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "addAllowlisted(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    isAllowlistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isAllowlistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalSupplyOnHoldByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "totalSupplyOnHoldByPartition(address,bytes32)"(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tokensToValidate(
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "tokensToValidate(bytes,bytes32,address,address,address,uint256,bytes,bytes)"(
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    preHoldForWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "preHoldForWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    executeHold(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "executeHold(address,bytes32,uint256,bytes32)"(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    unpause(token: string, overrides?: Overrides): Promise<BigNumber>;

    "unpause(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    spendableBalanceOf(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "spendableBalanceOf(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    renounceMinter(token: string, overrides?: Overrides): Promise<BigNumber>;

    "renounceMinter(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    usedCertificateSalt(
      token: string,
      salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "usedCertificateSalt(address,bytes32)"(
      token: string,
      salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isAllowlisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isAllowlisted(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setGranularityByPartition(
      token: string,
      partition: BytesLike,
      granularity: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "setGranularityByPartition(address,bytes32,uint256)"(
      token: string,
      partition: BytesLike,
      granularity: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    removeAllowlisted(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "removeAllowlisted(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    executeHoldAndKeepOpen(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "executeHoldAndKeepOpen(address,bytes32,uint256,bytes32)"(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    spendableBalanceOfByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "spendableBalanceOfByPartition(address,bytes32,address)"(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hold(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "hold(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    pause(token: string, overrides?: Overrides): Promise<BigNumber>;

    "pause(address)"(token: string, overrides?: Overrides): Promise<BigNumber>;

    holdWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "holdWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    canValidate(
      token: string,
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "canValidate(address,bytes,bytes32,address,address,address,uint256,bytes,bytes)"(
      token: string,
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    holdFromWithExpirationDate(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "holdFromWithExpirationDate(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    removeBlocklisted(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "removeBlocklisted(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    isCertificateSigner(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isCertificateSigner(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isBlocklistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isBlocklistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isBlocklisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isBlocklisted(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    granularityByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "granularityByPartition(address,bytes32)"(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    retrieveTokenSetup(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "retrieveTokenSetup(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    renewHoldWithExpirationDate(
      token: string,
      holdId: BytesLike,
      expiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "renewHoldWithExpirationDate(address,bytes32,uint256,bytes)"(
      token: string,
      holdId: BytesLike,
      expiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    releaseHold(
      token: string,
      holdId: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "releaseHold(address,bytes32)"(
      token: string,
      holdId: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    addBlocklistAdmin(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "addBlocklistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    addCertificateSigner(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "addCertificateSigner(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    renewHold(
      token: string,
      holdId: BytesLike,
      timeToExpiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "renewHold(address,bytes32,uint256,bytes)"(
      token: string,
      holdId: BytesLike,
      timeToExpiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    removeAllowlistAdmin(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "removeAllowlistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    renounceBlocklistAdmin(
      token: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "renounceBlocklistAdmin(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    balanceOnHoldByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "balanceOnHoldByPartition(address,bytes32,address)"(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    removeCertificateSigner(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "removeCertificateSigner(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    addPauser(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "addPauser(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    removeBlocklistAdmin(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "removeBlocklistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    removePauser(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "removePauser(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    addAllowlistAdmin(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "addAllowlistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    renounceAllowlistAdmin(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "renounceAllowlistAdmin(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    registerTokenSetup(
      token: string,
      certificateActivated: BigNumberish,
      allowlistActivated: boolean,
      blocklistActivated: boolean,
      granularityByPartitionActivated: boolean,
      holdsActivated: boolean,
      operators: string[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "registerTokenSetup(address,uint8,bool,bool,bool,bool,address[])"(
      token: string,
      certificateActivated: BigNumberish,
      allowlistActivated: boolean,
      blocklistActivated: boolean,
      granularityByPartitionActivated: boolean,
      holdsActivated: boolean,
      operators: string[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    retrieveHoldData(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "retrieveHoldData(address,bytes32)"(
      token: string,
      holdId: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalSupplyOnHold(
      token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "totalSupplyOnHold(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    balanceOnHold(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "balanceOnHold(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    holdFrom(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "holdFrom(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    canImplementInterfaceForAddress(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "canImplementInterfaceForAddress(bytes32,address)"(
      interfaceHash: BytesLike,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    usedCertificateNonce(
      token: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "usedCertificateNonce(address,address)"(
      token: string,
      sender: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    preHoldFor(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "preHoldFor(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    addBlocklisted(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addBlocklisted(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    paused(
      token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "paused(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isPauser(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isPauser(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    renounceCertificateSigner(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "renounceCertificateSigner(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    renouncePauser(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "renouncePauser(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    addAllowlisted(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addAllowlisted(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    isAllowlistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isAllowlistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalSupplyOnHoldByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "totalSupplyOnHoldByPartition(address,bytes32)"(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tokensToValidate(
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "tokensToValidate(bytes,bytes32,address,address,address,uint256,bytes,bytes)"(
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    preHoldForWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "preHoldForWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    executeHold(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "executeHold(address,bytes32,uint256,bytes32)"(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    unpause(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "unpause(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    spendableBalanceOf(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "spendableBalanceOf(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    renounceMinter(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "renounceMinter(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    usedCertificateSalt(
      token: string,
      salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "usedCertificateSalt(address,bytes32)"(
      token: string,
      salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isAllowlisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isAllowlisted(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setGranularityByPartition(
      token: string,
      partition: BytesLike,
      granularity: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "setGranularityByPartition(address,bytes32,uint256)"(
      token: string,
      partition: BytesLike,
      granularity: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    removeAllowlisted(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "removeAllowlisted(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    executeHoldAndKeepOpen(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "executeHoldAndKeepOpen(address,bytes32,uint256,bytes32)"(
      token: string,
      holdId: BytesLike,
      value: BigNumberish,
      secret: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    spendableBalanceOfByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "spendableBalanceOfByPartition(address,bytes32,address)"(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hold(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "hold(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      timeToExpiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    pause(token: string, overrides?: Overrides): Promise<PopulatedTransaction>;

    "pause(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    holdWithExpirationDate(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "holdWithExpirationDate(address,bytes32,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    canValidate(
      token: string,
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "canValidate(address,bytes,bytes32,address,address,address,uint256,bytes,bytes)"(
      token: string,
      payload: BytesLike,
      partition: BytesLike,
      operator: string,
      from: string,
      to: string,
      value: BigNumberish,
      data: BytesLike,
      operatorData: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    holdFromWithExpirationDate(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "holdFromWithExpirationDate(address,bytes32,address,address,address,bytes32,uint256,uint256,bytes32,bytes)"(
      token: string,
      holdId: BytesLike,
      sender: string,
      recipient: string,
      notary: string,
      partition: BytesLike,
      value: BigNumberish,
      expiration: BigNumberish,
      secretHash: BytesLike,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    removeBlocklisted(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "removeBlocklisted(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    isCertificateSigner(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isCertificateSigner(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isBlocklistAdmin(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isBlocklistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isBlocklisted(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isBlocklisted(address,address)"(
      token: string,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    granularityByPartition(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "granularityByPartition(address,bytes32)"(
      token: string,
      partition: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    retrieveTokenSetup(
      token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "retrieveTokenSetup(address)"(
      token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    renewHoldWithExpirationDate(
      token: string,
      holdId: BytesLike,
      expiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "renewHoldWithExpirationDate(address,bytes32,uint256,bytes)"(
      token: string,
      holdId: BytesLike,
      expiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    releaseHold(
      token: string,
      holdId: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "releaseHold(address,bytes32)"(
      token: string,
      holdId: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    addBlocklistAdmin(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addBlocklistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    addCertificateSigner(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addCertificateSigner(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    renewHold(
      token: string,
      holdId: BytesLike,
      timeToExpiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "renewHold(address,bytes32,uint256,bytes)"(
      token: string,
      holdId: BytesLike,
      timeToExpiration: BigNumberish,
      certificate: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    removeAllowlistAdmin(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "removeAllowlistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    renounceBlocklistAdmin(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "renounceBlocklistAdmin(address)"(
      token: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    balanceOnHoldByPartition(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "balanceOnHoldByPartition(address,bytes32,address)"(
      token: string,
      partition: BytesLike,
      account: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    removeCertificateSigner(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "removeCertificateSigner(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    addPauser(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addPauser(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    removeBlocklistAdmin(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "removeBlocklistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    removePauser(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "removePauser(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    addAllowlistAdmin(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "addAllowlistAdmin(address,address)"(
      token: string,
      account: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;
  };
}
